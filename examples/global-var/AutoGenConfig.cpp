// This file is auto-generated by taxi v1.2.3, DO NOT EDIT!

#include "stdafx.h"
#include <stddef.h>
#include <memory>
#include "AutogenConfig.h"
#include "Utility/Conv.h"
#include "Resource/ResourceManager.h"

using namespace std;


namespace config
{

namespace {
    static GlobalPropertyDefine* _instance_globalpropertydefine = nullptr;
}

// clear all configuration
void LoadAllAutogenConfig()
{
    GlobalPropertyDefine::Load();
}

// load all configurations
void ClearAllAutogenConfig()
{
    BEATS_SAFE_DELETE(_instance_globalpropertydefine);
}

const GlobalPropertyDefine* GlobalPropertyDefine::Instance()
{
    BEATS_ASSERT(_instance_globalpropertydefine != nullptr);
    return _instance_globalpropertydefine;
}

// load data from csv file
int GlobalPropertyDefine::Load(const char* filepath /* = nullptr */)
{
    if (filepath == nullptr)
    {
        filepath = "/csv/globalpropertydefine.csv";
    }
    const string& path = CResourceManager::GetInstance()->GetResourcePath(eRT_Resource) + filepath;
    CSerializer serializer(path.c_str());
    StringPiece content((const char*)serializer.GetBuffer(), serializer.GetWritePos());
    vector<vector<StringPiece>> rows;
    auto lines = Split(content, "\r\n");
    BEATS_ASSERT(!lines.empty());
    for (size_t i = 0; i < lines.size(); i++)
    {
        if (!lines[i].empty())
        {
            const auto& row = Split(lines[i], ",");
            if (!row.empty())
            {
                rows.push_back(row);
            }
        }
    }
    GlobalPropertyDefine* dataptr = BEATS_NEW(GlobalPropertyDefine, "autogen", filepath);
    GlobalPropertyDefine::ParseFromRows(rows, dataptr);
    BEATS_SAFE_DELETE(_instance_globalpropertydefine);
    _instance_globalpropertydefine = dataptr;
    return 0;
}

// parse data object from csv rows
int GlobalPropertyDefine::ParseFromRows(const vector<vector<StringPiece>>& rows, GlobalPropertyDefine* ptr)
{
    BEATS_ASSERT(rows.size() >= 9 && rows[0].size() >= 3);
    BEATS_ASSERT(ptr != nullptr);
    if (!rows[0][3].empty())
    {
        ptr->GoldExchangeTimeFactor1 = to<float>(rows[0][3]);
    }
    if (!rows[1][3].empty())
    {
        ptr->GoldExchangeTimeFactor2 = to<float>(rows[1][3]);
    }
    if (!rows[2][3].empty())
    {
        ptr->GoldExchangeTimeFactor3 = to<float>(rows[2][3]);
    }
    if (!rows[3][3].empty())
    {
        ptr->GoldExchangeResource1Price = to<uint32_t>(rows[3][3]);
    }
    if (!rows[4][3].empty())
    {
        ptr->GoldExchangeResource2Price = to<uint32_t>(rows[4][3]);
    }
    if (!rows[5][3].empty())
    {
        ptr->GoldExchangeResource3Price = to<uint32_t>(rows[5][3]);
    }
    if (!rows[6][3].empty())
    {
        ptr->GoldExchangeResource4Price = to<uint32_t>(rows[6][3]);
    }
    if (!rows[7][3].empty())
    {
        ptr->FreeCompleteSeconds = to<uint32_t>(rows[7][3]);
    }
    if (!rows[8][3].empty())
    {
        ptr->CancelBuildReturnPercent = to<uint32_t>(rows[8][3]);
    }
    return 0;
}

} // namespace config 
